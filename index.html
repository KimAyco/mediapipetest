<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hand Landmark Detection using MediaPipe HandLandmarker</title>

  <!-- Material Components for styling -->
  <link href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css" rel="stylesheet">
  <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>

  <!-- MediaPipe Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

  <style>
    body {
      font-family: roboto;
      margin: 2em;
      color: #3d3d3d;
      --mdc-theme-primary: #007f8b;
      --mdc-theme-on-primary: #f1f3f4;
    }

    h1 {
      color: #007f8b;
    }

    h2 {
      clear: both;
    }

    em {
      font-weight: bold;
    }

    video {
      clear: both;
      display: block;
      transform: rotateY(180deg);
    }

    section {
      opacity: 1;
      transition: opacity 500ms ease-in-out;
    }

    header,
    footer {
      clear: both;
    }

    .removed {
      display: none;
    }

    .invisible {
      opacity: 0.2;
    }

    .note {
      font-style: italic;
      font-size: 130%;
    }

    .videoView,
    .detectOnClick {
      position: relative;
      float: left;
      width: 48%;
      margin: 2% 1%;
      cursor: pointer;
    }

    .videoView p,
    .detectOnClick p {
      position: absolute;
      padding: 5px;
      background-color: #007f8b;
      color: #fff;
      border: 1px dashed rgba(255, 255, 255, 0.7);
      z-index: 2;
      font-size: 12px;
      margin: 0;
    }

    .highlighter {
      background: rgba(0, 255, 0, 0.25);
      border: 1px dashed #fff;
      z-index: 1;
      position: absolute;
    }

    .canvas {
      z-index: 1;
      position: absolute;
      pointer-events: none;
    }

    .output_canvas {
      transform: rotateY(180deg);
    }

    .detectOnClick {
      z-index: 0;
    }

    .detectOnClick img {
      width: 100%;
    }

    #thumbLocation {
      margin-top: 20px;
      font-size: 18px;
      font-weight: bold;
    }

    #fingerTipsLocation {
      margin-top: 20px;
      font-size: 18px;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>Hand Landmark Detection using the MediaPipe HandLandmarker task</h1>

  <section id="demos" class="invisible">
    <h2>Demo: Detecting Images</h2>
    <p><b>Click on an image below</b> to see the key landmarks of the hands.</p>

    <div class="detectOnClick">
      <img src="https://assets.codepen.io/9177687/hand-ge4ca13f5d_1920.jpg" width="100%" crossorigin="anonymous" title="Click to get detection!" />
    </div>
    <div class="detectOnClick">
      <img src="https://assets.codepen.io/9177687/couple-gb7cb5db4c_1920.jpg" width="100%" crossorigin="anonymous" title="Click to get detection!" />
    </div>

    <h2>Demo: Webcam Continuous Hand Landmarks Detection</h2>
    <p>Hold your hand in front of your webcam to get real-time hand landmark detection.</br>Click <b>enable webcam</b> below and grant access to the webcam if prompted.</p>

    <div id="liveView" class="videoView">
      <button id="webcamButton" class="mdc-button mdc-button--raised">
        <span class="mdc-button__ripple"></span>
        <span class="mdc-button__label">ENABLE WEBCAM</span>
      </button>
      <div style="position: relative;">
        <video id="webcam" style="position: abso" autoplay playsinline></video>
        <canvas class="output_canvas" id="output_canvas" style="position: absolute; left: 0px; top: 0px;"></canvas>
      </div>
    </div>
    <!-- Display the thumb coordinates and all finger tips here -->
    <div id="thumbLocation">Thumb Coordinates: N/A</div>
    <div id="fingerTipsLocation">Finger Tips Coordinates: N/A</div>
  </section>

  <script type="module">
    import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

    const demosSection = document.getElementById("demos");
    let handLandmarker = undefined;
    let runningMode = "IMAGE";
    let enableWebcamButton;
    let webcamRunning = false;

    // Before we can use HandLandmarker class we must wait for it to finish loading.
    const createHandLandmarker = async () => {
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
      );
      handLandmarker = await HandLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
          delegate: "GPU"
        },
        runningMode: runningMode,
        numHands: 2
      });
      demosSection.classList.remove("invisible");
    };
    createHandLandmarker();

    // Detecting Images Demo
    const imageContainers = document.getElementsByClassName("detectOnClick");
    for (let i = 0; i < imageContainers.length; i++) {
      imageContainers[i].children[0].addEventListener("click", handleClick);
    }

    async function handleClick(event) {
      if (!handLandmarker) {
        console.log("Wait for handLandmarker to load before clicking!");
        return;
      }

      if (runningMode === "VIDEO") {
        runningMode = "IMAGE";
        await handLandmarker.setOptions({ runningMode: "IMAGE" });
      }

      // Remove all landmarks drawn before
      const allCanvas = event.target.parentNode.getElementsByClassName("canvas");
      for (var i = allCanvas.length - 1; i >= 0; i--) {
        const n = allCanvas[i];
        n.parentNode.removeChild(n);
      }

      // Detect image and display results
      const handLandmarkerResult = handLandmarker.detect(event.target);
      const canvas = document.createElement("canvas");
      canvas.setAttribute("class", "canvas");
      canvas.setAttribute("width", event.target.naturalWidth + "px");
      canvas.setAttribute("height", event.target.naturalHeight + "px");
      event.target.parentNode.appendChild(canvas);
      const cxt = canvas.getContext("2d");

      // Check if landmarks exist before accessing
      if (handLandmarkerResult.landmarks && handLandmarkerResult.landmarks.length > 0) {
        const thumbTip = handLandmarkerResult.landmarks[0][4]; // Thumb tip
        const indexTip = handLandmarkerResult.landmarks[0][8]; // Index tip
        const middleTip = handLandmarkerResult.landmarks[0][12]; // Middle tip
        const ringTip = handLandmarkerResult.landmarks[0][16]; // Ring tip
        const pinkyTip = handLandmarkerResult.landmarks[0][20]; // Pinky tip

        const thumbCoordinates = `Thumb X: ${thumbTip.x.toFixed(2)}, Y: ${thumbTip.y.toFixed(2)}`;
        const indexCoordinates = `Index X: ${indexTip.x.toFixed(2)}, Y: ${indexTip.y.toFixed(2)}`;
        const middleCoordinates = `Middle X: ${middleTip.x.toFixed(2)}, Y: ${middleTip.y.toFixed(2)}`;
        const ringCoordinates = `Ring X: ${ringTip.x.toFixed(2)}, Y: ${ringTip.y.toFixed(2)}`;
        const pinkyCoordinates = `Pinky X: ${pinkyTip.x.toFixed(2)}, Y: ${pinkyTip.y.toFixed(2)}`;

        // Update the display
        document.getElementById("thumbLocation").textContent = `Thumb Coordinates: ${thumbCoordinates}`;
        document.getElementById("fingerTipsLocation").textContent = `${indexCoordinates}, ${middleCoordinates}, ${ringCoordinates}, ${pinkyCoordinates}`;
      } else {
        // If no hand is detected, reset coordinates
        document.getElementById("thumbLocation").textContent = "Thumb Coordinates: N/A";
        document.getElementById("fingerTipsLocation").textContent = "Finger Tips Coordinates: N/A";
      }

      for (const landmarks of handLandmarkerResult.landmarks || []) {
        drawConnectors(cxt, landmarks, HAND_CONNECTIONS, {
          color: "#00FF00",
          lineWidth: 5
        });
        drawLandmarks(cxt, landmarks, { color: "#FF0000", lineWidth: 1 });
      }
    }

    // Webcam Demo
    const video = document.getElementById("webcam");
    const canvasElement = document.getElementById("output_canvas");
    const canvasCtx = canvasElement.getContext("2d");

    const hasGetUserMedia = () => !!navigator.mediaDevices?.getUserMedia;

    if (hasGetUserMedia()) {
      enableWebcamButton = document.getElementById("webcamButton");
      enableWebcamButton.addEventListener("click", enableCam);
    } else {
      console.warn("getUserMedia() is not supported by your browser");
    }

    function enableCam(event) {
      if (!handLandmarker) {
        console.log("Wait! objectDetector not loaded yet.");
        return;
      }

      if (webcamRunning === true) {
        webcamRunning = false;
        enableWebcamButton.innerText = "ENABLE PREDICTIONS";
      } else {
        webcamRunning = true;
        enableWebcamButton.innerText = "DISABLE PREDICTIONS";
      }

      const constraints = { video: true };

      navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
        video.srcObject = stream;
        video.addEventListener("loadeddata", predictWebcam);
      });
    }

    let lastVideoTime = -1;
    let results = undefined;

    // Throttle update interval to avoid performance issues
    let lastUpdateTime = 0;
    const updateInterval = 100; // Update every 100ms (10 times per second)

    async function predictWebcam() {
      const currentTime = performance.now();
      if (currentTime - lastUpdateTime < updateInterval) {
        requestAnimationFrame(predictWebcam);
        return;
      }

      canvasElement.style.width = video.videoWidth;
      canvasElement.style.height = video.videoHeight;
      canvasElement.width = video.videoWidth;
      canvasElement.height = video.videoHeight;

      if (runningMode === "IMAGE") {
        runningMode = "VIDEO";
        await handLandmarker.setOptions({ runningMode: "VIDEO" });
      }
      let startTimeMs = performance.now();
      if (lastVideoTime !== video.currentTime) {
        lastVideoTime = video.currentTime;
        results = handLandmarker.detectForVideo(video, startTimeMs);
      }
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

      // Check if landmarks exist before accessing
      if (results.landmarks && results.landmarks.length > 0) {
        const thumbTip = results.landmarks[0][4]; // Thumb tip
        const indexTip = results.landmarks[0][8]; // Index tip
        const middleTip = results.landmarks[0][12]; // Middle tip
        const ringTip = results.landmarks[0][16]; // Ring tip
        const pinkyTip = results.landmarks[0][20]; // Pinky tip

        const thumbCoordinates = `Thumb X: ${thumbTip.x.toFixed(2)}, Y: ${thumbTip.y.toFixed(2)}`;
        const indexCoordinates = `Index X: ${indexTip.x.toFixed(2)}, Y: ${indexTip.y.toFixed(2)}`;
        const middleCoordinates = `Middle X: ${middleTip.x.toFixed(2)}, Y: ${middleTip.y.toFixed(2)}`;
        const ringCoordinates = `Ring X: ${ringTip.x.toFixed(2)}, Y: ${ringTip.y.toFixed(2)}`;
        const pinkyCoordinates = `Pinky X: ${pinkyTip.x.toFixed(2)}, Y: ${pinkyTip.y.toFixed(2)}`;

        // Update the display
        document.getElementById("thumbLocation").textContent = `Thumb Coordinates: ${thumbCoordinates}`;
        document.getElementById("fingerTipsLocation").textContent = `${indexCoordinates}, ${middleCoordinates}, ${ringCoordinates}, ${pinkyCoordinates}`;
      } else {
        // If no hand is detected, reset coordinates
        document.getElementById("thumbLocation").textContent = "Thumb Coordinates: N/A";
        document.getElementById("fingerTipsLocation").textContent = "Finger Tips Coordinates: N/A";
      }

      canvasCtx.restore();
      lastUpdateTime = currentTime;

      if (webcamRunning === true) {
        window.requestAnimationFrame(predictWebcam);
      }
    }
  </script>
</body>
</html>
